========================================
WASMTIME INTEGRATION - CODE SUMMARY
========================================

FILE: /home/rbsmith4/ladybird/Services/Sentinel/Sandbox/WasmExecutor.cpp
LINES: 301-631 (331 lines)
STATUS: ✅ COMPLETE AND COMPILING

========================================
HEADERS ADDED
========================================

#include <AK/JsonObject.h>
#include <AK/JsonValue.h>

========================================
FUNCTION SIGNATURE
========================================

ErrorOr<WasmExecutionResult> WasmExecutor::execute_wasmtime(
    ByteBuffer const& file_data, 
    [[maybe_unused]] String const& filename)

========================================
KEY IMPLEMENTATION SECTIONS
========================================

STEP 1: MODULE INSTANTIATION (Lines 316-345)
---------------------------------------------
wasmtime_linker_t* linker = wasmtime_linker_new(engine);
wasmtime_linker_instantiate(linker, context, module, &instance, &trap);
// Error handling + cleanup

STEP 2: EXPORT RETRIEVAL (Lines 347-383)
------------------------------------------
wasmtime_instance_export_get(context, &instance, "allocate", 8, &allocate_extern);
wasmtime_instance_export_get(context, &instance, "analyze_file", 12, &analyze_extern);
wasmtime_instance_export_get(context, &instance, "deallocate", 10, &deallocate_extern);
wasmtime_instance_export_get(context, &instance, "memory", 6, &memory_extern);
// Type validation

STEP 3: MEMORY ALLOCATION (Lines 385-417)
-------------------------------------------
wasmtime_val_t alloc_args[1];
alloc_args[0].kind = WASMTIME_I32;
alloc_args[0].of.i32 = static_cast<i32>(file_data.size());
wasmtime_func_call(context, &allocate_func, alloc_args, 1, alloc_results, 1, &trap);
i32 wasm_buffer_ptr = alloc_results[0].of.i32;

STEP 4: DATA TRANSFER (Lines 419-439)
---------------------------------------
u8* memory_data = wasmtime_memory_data(context, &memory);
size_t memory_size = wasmtime_memory_data_size(context, &memory);
// Bounds check
memcpy(memory_data + wasm_buffer_ptr, file_data.data(), file_data.size());

STEP 5: ANALYSIS EXECUTION (Lines 441-500)
--------------------------------------------
wasmtime_val_t analyze_args[2];
analyze_args[0].of.i32 = wasm_buffer_ptr;
analyze_args[1].of.i32 = static_cast<i32>(file_data.size());
wasmtime_func_call(context, &analyze_func, analyze_args, 2, analyze_results, 1, &trap);
i32 result_ptr = analyze_results[0].of.i32;

STEP 6: RESULT EXTRACTION (Lines 505-536)
-------------------------------------------
char const* json_start = reinterpret_cast<char const*>(memory_data + result_ptr);
size_t json_length = 0;
while (json_start[json_length] != '\0' && json_length < 1024*1024) {
    json_length++;
}
StringView json_string { json_start, json_length };

STEP 7: JSON PARSING (Lines 538-595)
--------------------------------------
auto json = TRY(JsonValue::from_string(json_string));
auto const& obj = json.as_object();

result.yara_score = obj.get_float_with_precision_loss("yara_score"sv).value_or(0.0f);
result.ml_score = obj.get_float_with_precision_loss("ml_score"sv).value_or(0.0f);

if (auto behaviors = obj.get_array("behaviors"sv); behaviors.has_value()) {
    for (auto const& behavior : behaviors.value().values()) {
        if (behavior.is_string())
            TRY(result.detected_behaviors.try_append(behavior.as_string()));
    }
}

if (auto rules = obj.get_array("triggered_rules"sv); rules.has_value()) {
    for (auto const& rule : rules.value().values()) {
        if (rule.is_string())
            TRY(result.triggered_rules.try_append(rule.as_string()));
    }
}

STEP 8: MEMORY CLEANUP (Lines 597-620)
----------------------------------------
wasmtime_val_t dealloc_args[1];
dealloc_args[0].of.i32 = wasm_buffer_ptr;
wasmtime_func_call(context, &deallocate_func, dealloc_args, 1, nullptr, 0, &trap);
// Non-fatal error handling

return result;

========================================
ERROR HANDLING PATTERN
========================================

Every error path:
1. Logs error with dbgln()
2. Cleans up resources (deallocate, delete)
3. Returns Error::from_string_literal()
4. NO FALLBACK to stub mode

Example:
if (error) {
    wasm_name_t error_msg;
    wasmtime_error_message(error, &error_msg);
    dbgln("WasmExecutor: Failed: {}", StringView { error_msg.data, error_msg.size });
    wasm_name_delete(&error_msg);
    wasmtime_error_delete(error);
    
    // Cleanup
    wasmtime_val_t dealloc_args[1];
    dealloc_args[0].of.i32 = wasm_buffer_ptr;
    wasmtime_func_call(context, &deallocate_func, dealloc_args, 1, nullptr, 0, &trap);
    if (trap) wasm_trap_delete(trap);
    
    return Error::from_string_literal("Operation failed");
}

========================================
BUILD VERIFICATION
========================================

$ cd /home/rbsmith4/ladybird/Build/release
$ ninja sentinelservice

[1/2] Building CXX object Services/Sentinel/CMakeFiles/sentinelservice.dir/Sandbox/WasmExecutor.cpp.o
[2/2] Linking CXX static library lib/libsentinelservice.a

✅ SUCCESS - No errors, no warnings

========================================
PERFORMANCE CHARACTERISTICS
========================================

Target: <100ms total
Fuel: 500M instructions
Memory: Configurable limit
Timeout: Epoch-based interruption

Expected breakdown:
- Instantiation: <5ms (cached)
- Allocation: <1ms
- Copy: <5ms
- Analysis: 50-90ms
- Parsing: <1ms
- Cleanup: <1ms
Total: 60-100ms ✅

========================================
NEXT STEPS
========================================

1. Create test WASM module at:
   /home/rbsmith4/ladybird/Services/Sentinel/assets/malware_analyzer.wasm

2. Test with sample files

3. Verify JSON output format

4. Measure actual performance

========================================
