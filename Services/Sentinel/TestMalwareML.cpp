/*
 * Copyright (c) 2025, Ladybird contributors
 * SPDX-License-Identifier: BSD-2-Clause
 */

#include "MalwareML.h"
#include <AK/StringView.h>
#include <LibMain/Main.h>
#include <stdio.h>

using namespace Sentinel;

static int tests_passed = 0;
static int tests_failed = 0;

static void log_pass(StringView test_name)
{
    printf("✅ PASSED: %s\n", test_name.characters_without_null_termination());
    tests_passed++;
}

static void log_fail(StringView test_name, StringView reason)
{
    printf("❌ FAILED: %s - %s\n",
           test_name.characters_without_null_termination(),
           reason.characters_without_null_termination());
    tests_failed++;
}

static void print_section(StringView title)
{
    printf("\n=== %s ===\n", title.characters_without_null_termination());
}

// Test 1: Feature extraction from benign file
static void test_benign_file_features()
{
    print_section("Test 1: Benign File Feature Extraction"sv);

    // Create a simple benign file (small text file)
    ByteBuffer benign_data;
    benign_data.append("Hello World! This is a test file.\n"sv.bytes());
    benign_data.append("It contains normal text data.\n"sv.bytes());
    benign_data.append("No suspicious content here.\n"sv.bytes());

    auto detector = MalwareMLDetector::create("/tmp/dummy_model.tflite");
    if (detector.is_error()) {
        log_fail("Benign file features"sv, "Failed to create detector"sv);
        return;
    }

    auto features = detector.value()->extract_features(benign_data);
    if (features.is_error()) {
        log_fail("Benign file features"sv, "Failed to extract features"sv);
        return;
    }

    printf("  File size: %lu bytes\n", features.value().file_size);
    printf("  Entropy: %.2f\n", features.value().entropy);
    printf("  Suspicious strings: %u\n", features.value().suspicious_strings);

    if (features.value().entropy < 5.0f) {
        log_pass("Benign file has low entropy"sv);
    } else {
        log_fail("Benign file entropy"sv, "Expected low entropy for text file"sv);
    }
}

// Test 2: Feature extraction from suspicious file
static void test_suspicious_file_features()
{
    print_section("Test 2: Suspicious File Feature Extraction"sv);

    // Create a suspicious-looking file with high entropy and suspicious content
    ByteBuffer suspicious_data;

    // Add random-looking bytes (high entropy)
    for (size_t i = 0; i < 1000; i++) {
        suspicious_data.append(static_cast<u8>(i * 137 + 42)); // Pseudo-random
    }

    // Add suspicious strings
    suspicious_data.append("http://malicious-site.com/payload.exe\n"sv.bytes());
    suspicious_data.append("CreateRemoteThread\n"sv.bytes());
    suspicious_data.append("VirtualAlloc\n"sv.bytes());
    suspicious_data.append("WriteProcessMemory\n"sv.bytes());
    suspicious_data.append("192.168.1.100\n"sv.bytes());

    auto detector = MalwareMLDetector::create("/tmp/dummy_model.tflite");
    if (detector.is_error()) {
        log_fail("Suspicious file features"sv, "Failed to create detector"sv);
        return;
    }

    auto features = detector.value()->extract_features(suspicious_data);
    if (features.is_error()) {
        log_fail("Suspicious file features"sv, "Failed to extract features"sv);
        return;
    }

    printf("  File size: %lu bytes\n", features.value().file_size);
    printf("  Entropy: %.2f\n", features.value().entropy);
    printf("  Suspicious strings: %u\n", features.value().suspicious_strings);

    if (features.value().entropy > 6.0f && features.value().suspicious_strings > 10) {
        log_pass("Suspicious file detected via features"sv);
    } else {
        log_fail("Suspicious file detection"sv, "Expected high entropy and suspicious strings"sv);
    }
}

// Test 3: PE file structure analysis
static void test_pe_file_analysis()
{
    print_section("Test 3: PE File Structure Analysis"sv);

    // Create a minimal PE file (DOS header + PE signature)
    ByteBuffer pe_data;

    // DOS header (starts with "MZ")
    pe_data.append("MZ"sv.bytes());
    for (size_t i = 0; i < 58; i++)
        pe_data.append(static_cast<u8>(0));

    // PE offset at 0x3C (points to offset 128)
    pe_data.append(static_cast<u8>(128));
    pe_data.append(static_cast<u8>(0));
    pe_data.append(static_cast<u8>(0));
    pe_data.append(static_cast<u8>(0));

    // Padding up to PE signature
    while (pe_data.size() < 128)
        pe_data.append(static_cast<u8>(0));

    // PE signature "PE\0\0"
    pe_data.append("PE"sv.bytes());
    pe_data.append(static_cast<u8>(0));
    pe_data.append(static_cast<u8>(0));

    // Add some more data to make it look like a PE
    pe_data.append("kernel32.dll"sv.bytes());
    pe_data.append(static_cast<u8>(0));
    pe_data.append("user32.dll"sv.bytes());
    pe_data.append(static_cast<u8>(0));

    auto detector = MalwareMLDetector::create("/tmp/dummy_model.tflite");
    if (detector.is_error()) {
        log_fail("PE file analysis"sv, "Failed to create detector"sv);
        return;
    }

    auto features = detector.value()->extract_features(pe_data);
    if (features.is_error()) {
        log_fail("PE file analysis"sv, "Failed to extract features"sv);
        return;
    }

    printf("  PE header anomalies: %u\n", features.value().pe_header_anomalies);
    printf("  Import table size: %u\n", features.value().import_table_size);
    printf("  Code section ratio: %.2f\n", features.value().code_section_ratio);

    if (features.value().import_table_size > 0) {
        log_pass("PE imports detected"sv);
    } else {
        log_fail("PE imports"sv, "Expected to detect kernel32.dll import"sv);
    }
}

// Test 4: Prediction on benign data
static void test_prediction_benign()
{
    print_section("Test 4: Prediction on Benign Data"sv);

    ByteBuffer benign_data;
    benign_data.append("Normal file content with low entropy.\n"sv.bytes());

    auto detector = MalwareMLDetector::create("/tmp/dummy_model.tflite");
    if (detector.is_error()) {
        log_fail("Benign prediction"sv, "Failed to create detector"sv);
        return;
    }

    auto prediction = detector.value()->analyze_file(benign_data);
    if (prediction.is_error()) {
        log_fail("Benign prediction"sv, "Prediction failed"sv);
        return;
    }

    printf("  Malware probability: %.2f\n", prediction.value().malware_probability);
    printf("  Confidence: %.2f\n", prediction.value().confidence);
    printf("  Explanation: %s\n", prediction.value().explanation.bytes_as_string_view().characters_without_null_termination());

    if (prediction.value().malware_probability < 0.5f) {
        log_pass("Benign file classified correctly"sv);
    } else {
        log_fail("Benign prediction"sv, "False positive - benign file marked as malware"sv);
    }
}

// Test 5: Prediction on malicious-looking data
static void test_prediction_malware()
{
    print_section("Test 5: Prediction on Malicious-Looking Data"sv);

    ByteBuffer malware_data;

    // High entropy data
    for (size_t i = 0; i < 2000; i++) {
        malware_data.append(static_cast<u8>(i * 137 + 42));
    }

    // Many suspicious API calls
    malware_data.append("VirtualAlloc"sv.bytes());
    malware_data.append("CreateRemoteThread"sv.bytes());
    malware_data.append("WriteProcessMemory"sv.bytes());
    malware_data.append("http://evil.com/payload.exe"sv.bytes());
    for (int i = 0; i < 20; i++) {
        malware_data.append("http://suspicious.tk/data"sv.bytes());
    }

    auto detector = MalwareMLDetector::create("/tmp/dummy_model.tflite");
    if (detector.is_error()) {
        log_fail("Malware prediction"sv, "Failed to create detector"sv);
        return;
    }

    auto prediction = detector.value()->analyze_file(malware_data);
    if (prediction.is_error()) {
        log_fail("Malware prediction"sv, "Prediction failed"sv);
        return;
    }

    printf("  Malware probability: %.2f\n", prediction.value().malware_probability);
    printf("  Confidence: %.2f\n", prediction.value().confidence);
    printf("  Explanation: %s\n", prediction.value().explanation.bytes_as_string_view().characters_without_null_termination());

    if (prediction.value().malware_probability > 0.5f) {
        log_pass("Malware-like file detected"sv);
    } else {
        log_fail("Malware prediction"sv, "False negative - malware-like file not detected"sv);
    }
}

// Test 6: Statistics tracking
static void test_statistics()
{
    print_section("Test 6: Statistics Tracking"sv);

    auto detector = MalwareMLDetector::create("/tmp/dummy_model.tflite");
    if (detector.is_error()) {
        log_fail("Statistics"sv, "Failed to create detector"sv);
        return;
    }

    // Run several predictions
    ByteBuffer data;
    data.append("test"sv.bytes());

    for (int i = 0; i < 5; i++) {
        auto prediction = detector.value()->analyze_file(data);
        if (prediction.is_error()) continue;
    }

    auto stats = detector.value()->get_statistics();
    printf("  Total predictions: %lu\n", stats.total_predictions);
    printf("  Malware detected: %lu\n", stats.malware_detected);
    printf("  Benign classified: %lu\n", stats.benign_classified);
    printf("  Average inference time: %.2f ms\n", stats.average_inference_time_ms);

    if (stats.total_predictions == 5) {
        log_pass("Statistics tracked correctly"sv);
    } else {
        log_fail("Statistics"sv, "Prediction count mismatch"sv);
    }
}

ErrorOr<int> ladybird_main(Main::Arguments)
{
    printf("====================================\n");
    printf("  MalwareML Detection Tests\n");
    printf("====================================\n");
    printf("  Phase 1: ML Infrastructure\n");
    printf("  Milestone 0.4\n");
    printf("====================================\n");

    test_benign_file_features();
    test_suspicious_file_features();
    test_pe_file_analysis();
    test_prediction_benign();
    test_prediction_malware();
    test_statistics();

    printf("\n====================================\n");
    printf("  Test Summary\n");
    printf("====================================\n");
    printf("  Passed: %d\n", tests_passed);
    printf("  Failed: %d\n", tests_failed);
    printf("  Total:  %d\n", tests_passed + tests_failed);
    printf("====================================\n\n");

    if (tests_failed > 0) {
        printf("❌ Some tests FAILED\n");
        return 1;
    }

    printf("✅ All tests PASSED\n");
    printf("\nNOTE: This is using heuristic-based detection.\n");
    printf("Integration with TensorFlow Lite coming in future updates.\n");
    return 0;
}
