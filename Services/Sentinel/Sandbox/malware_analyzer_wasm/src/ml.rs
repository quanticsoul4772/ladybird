pub fn calculate_entropy(data: &[u8]) -> f32 {
    if data.is_empty() {
        return 0.0;
    }

    let mut counts = [0u32; 256];
    for &byte in data {
        counts[byte as usize] += 1;
    }

    let len = data.len() as f32;
    let mut entropy = 0.0f32;

    for &count in &counts {
        if count > 0 {
            let p = count as f32 / len;
            entropy -= p * libm::log2f(p);
        }
    }

    entropy
}

pub fn calculate_ml_score(data: &[u8], entropy: f32, pe_anomalies: u32) -> f32 {
    let mut score = 0.0f32;

    // Entropy-based scoring
    if entropy > 7.0 {
        score += 0.3;
    } else if entropy > 6.0 {
        score += 0.15;
    }

    // PE anomalies
    if pe_anomalies > 20 {
        score += 0.25;
    } else if pe_anomalies > 5 {
        score += 0.1;
    }

    // PE header detection
    if data.len() > 2 && data[0] == b'M' && data[1] == b'Z' {
        // Simple PE anomaly check
        if data.len() > 64 {
            // Check for invalid PE offset
            if data.len() > 0x3F {
                let pe_offset = read_u32_le(data, 0x3C) as usize;
                if pe_offset > data.len() || pe_offset == 0 {
                    score += 0.15;
                }
            }
        }
    }

    // Code ratio (simplified)
    let printable_count = data.iter().filter(|&&b| b >= 0x20 && b <= 0x7E).count();
    let code_ratio = printable_count as f32 / data.len() as f32;
    if code_ratio < 0.2 || code_ratio > 0.9 {
        score += 0.15;
    }

    score.min(1.0)
}

// Helper: read little-endian u32
fn read_u32_le(data: &[u8], offset: usize) -> u32 {
    if offset + 4 > data.len() {
        return 0;
    }
    u32::from_le_bytes([
        data[offset],
        data[offset + 1],
        data[offset + 2],
        data[offset + 3],
    ])
}

// Minimal libm replacement for log2
mod libm {
    pub fn log2f(x: f32) -> f32 {
        // Use built-in log2 approximation
        // This is a simple Newton-Raphson approximation
        if x <= 0.0 {
            return f32::NEG_INFINITY;
        }
        if x == 1.0 {
            return 0.0;
        }

        // Extract exponent and mantissa
        let bits = x.to_bits();
        let exponent = ((bits >> 23) & 0xFF) as i32 - 127;
        let mantissa = (bits & 0x7FFFFF) | 0x3F800000;
        let m = f32::from_bits(mantissa);

        // log2(x) = exponent + log2(mantissa)
        // Approximate log2(m) for m in [1, 2)
        // Using polynomial approximation: log2(m) â‰ˆ -1.7417939 + (2.8212026 + (-1.4699568 + (0.44717955 - 0.056570851 * m) * m) * m) * m
        let m2 = m * m;
        let m3 = m2 * m;
        let m4 = m3 * m;
        let log2_m = -1.7417939 + 2.8212026 * m - 1.4699568 * m2 + 0.44717955 * m3 - 0.056570851 * m4;

        exponent as f32 + log2_m
    }
}
