pub struct Pattern {
    #[allow(dead_code)]
    pub name: &'static str,
    pub pattern: &'static [u8],
    pub severity: u32,
}

// High severity (15 points)
pub const HIGH_SEVERITY_PATTERNS: &[Pattern] = &[
    Pattern { name: "VirtualAlloc", pattern: b"VirtualAlloc", severity: 15 },
    Pattern { name: "VirtualProtect", pattern: b"VirtualProtect", severity: 15 },
    Pattern { name: "WriteProcessMemory", pattern: b"WriteProcessMemory", severity: 15 },
    Pattern { name: "CreateRemoteThread", pattern: b"CreateRemoteThread", severity: 15 },
    Pattern { name: "LoadLibrary", pattern: b"LoadLibrary", severity: 15 },
    Pattern { name: "GetProcAddress", pattern: b"GetProcAddress", severity: 15 },
    Pattern { name: "NtSetContextThread", pattern: b"NtSetContextThread", severity: 15 },
    Pattern { name: "SetWindowsHookEx", pattern: b"SetWindowsHookEx", severity: 15 },
    Pattern { name: "ZwUnmapViewOfSection", pattern: b"ZwUnmapViewOfSection", severity: 15 },
    Pattern { name: "RtlCreateUserThread", pattern: b"RtlCreateUserThread", severity: 15 },
];

// Medium severity (5 points)
pub const MEDIUM_SEVERITY_PATTERNS: &[Pattern] = &[
    Pattern { name: "http_url", pattern: b"http://", severity: 5 },
    Pattern { name: "https_url", pattern: b"https://", severity: 5 },
    Pattern { name: "ftp_url", pattern: b"ftp://", severity: 5 },
    Pattern { name: "cmd_exe", pattern: b"cmd.exe", severity: 5 },
    Pattern { name: "powershell", pattern: b"powershell", severity: 5 },
    Pattern { name: "bash", pattern: b"bash", severity: 5 },
    Pattern { name: "bin_sh", pattern: b"/bin/sh", severity: 5 },
];

// Low severity (2 points)
pub const LOW_SEVERITY_PATTERNS: &[Pattern] = &[
    Pattern { name: "eval", pattern: b"eval(", severity: 2 },
    Pattern { name: "exec", pattern: b"exec(", severity: 2 },
    Pattern { name: "base64", pattern: b"base64", severity: 2 },
    Pattern { name: "encrypt", pattern: b"encrypt", severity: 2 },
    Pattern { name: "decrypt", pattern: b"decrypt", severity: 2 },
    Pattern { name: "bitcoin", pattern: b"bitcoin", severity: 2 },
    Pattern { name: "wallet", pattern: b"wallet", severity: 2 },
];

pub fn scan_patterns(data: &[u8]) -> (u32, u32) {
    let mut total_score = 0u32;
    let mut pattern_count = 0u32;

    // Normalize data for case-insensitive matching
    // Use 64KB buffer to avoid stack overflow in WASM
    let mut normalized = [0u8; 65536]; // 64KB buffer
    let norm_len = data.len().min(normalized.len());

    for i in 0..norm_len {
        normalized[i] = if data[i].is_ascii_alphabetic() {
            data[i].to_ascii_lowercase()
        } else {
            data[i]
        };
    }

    let normalized_data = &normalized[..norm_len];

    for pattern in HIGH_SEVERITY_PATTERNS.iter()
        .chain(MEDIUM_SEVERITY_PATTERNS.iter())
        .chain(LOW_SEVERITY_PATTERNS.iter())
    {
        // Normalize pattern for comparison
        let mut norm_pattern = [0u8; 64]; // Max pattern size
        for (i, &byte) in pattern.pattern.iter().enumerate().take(64) {
            norm_pattern[i] = if byte.is_ascii_alphabetic() {
                byte.to_ascii_lowercase()
            } else {
                byte
            };
        }

        let count = count_occurrences(normalized_data, &norm_pattern[..pattern.pattern.len()]);
        if count > 0 {
            total_score += pattern.severity * count;
            pattern_count += count;
        }
    }

    (total_score, pattern_count)
}

fn count_occurrences(haystack: &[u8], needle: &[u8]) -> u32 {
    if needle.is_empty() || needle.len() > haystack.len() {
        return 0;
    }

    let mut count = 0;
    let max_pos = haystack.len() - needle.len() + 1;

    for i in 0..max_pos {
        let mut matches = true;
        for j in 0..needle.len() {
            if haystack[i + j] != needle[j] {
                matches = false;
                break;
            }
        }
        if matches {
            count += 1;
        }
    }

    count
}
