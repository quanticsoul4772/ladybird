# Advanced Malware Pattern Detection - Implementation Report

**Task:** Week 2 Task 2 - Malware Family Detection Methods
**Date:** 2025-11-02
**Status:** ✅ COMPLETE

## Overview

Added five specialized malware pattern detection methods to `BehavioralAnalyzer` class to identify specific malware families based on behavioral metrics captured during sandbox execution.

## Methods Implemented

### 1. `detect_ransomware_pattern()`

**Detection Logic:**
- Primary indicator: `file_operations > 50` (rapid file access)
- Secondary indicators:
  - Excessive file operations: `file_operations > 100`
  - Executable drops or temp files: `executable_drops > 0 || temp_file_creates > 5`
  - Network beaconing: `outbound_connections > 0` combined with high file ops

**Rationale:**
- Ransomware encrypts many files rapidly (high file_operations)
- After encryption, original files are deleted (would show in unlink syscalls)
- Ransom notes dropped as executables or temp files
- C2 communication for payment instructions

**False Positive Mitigation:**
- Conservative threshold of 50 operations to avoid flagging build systems
- Requires multiple indicators (encryption + drops + network)
- Future enhancement: Track unlink/write ratio specifically

---

### 2. `detect_keylogger_pattern()`

**Detection Logic:**
- Requires **2 or more** indicators from:
  - Moderate file logging: `10 < file_operations < 100`
  - Hidden file creation: `hidden_file_creates > 0`
  - Network exfiltration: `outbound_connections > 0 && network_operations > 5`
  - Persistence mechanism: `persistence_mechanisms > 0`

**Rationale:**
- Keyloggers log keystrokes to files (moderate file ops)
- Output files often hidden (.dotfiles)
- Captured data exfiltrated via network
- Persistence ensures continuous monitoring

**False Positive Mitigation:**
- Multi-indicator approach (requires 2+ signals)
- File operation range excludes both low-activity and high-activity programs
- Future enhancement: Track /dev/input/* access patterns

---

### 3. `detect_rootkit_pattern()`

**Detection Logic:**
- **Primary indicator (immediate detection):**
  - `privilege_escalation_attempts > 0`
- **Secondary indicators:**
  - File + process manipulation: `file_operations > 20 && process_operations > 3`
  - Memory + injection: `memory_operations > 10 && code_injection_attempts > 0`
  - Service modification: `service_modifications > 0`

**Rationale:**
- Rootkits attempt kernel-level control via privilege escalation
- Includes: setuid, capset, mount, unshare, chroot, kernel modules
- Combines system-level operations across multiple categories

**False Positive Mitigation:**
- In sandbox context, ANY privilege escalation is highly suspicious
- Legitimate programs don't need setuid/mount in sandboxed execution
- seccomp should block these operations, so attempts indicate malicious intent

---

### 4. `detect_cryptominer_pattern()`

**Detection Logic:**
- **Requires BOTH conditions:**
  1. Network beaconing: `network_operations > 10 && outbound_connections > 5`
  2. Resource-intensive operations (ANY of):
     - High memory usage: `memory_operations > 20`
     - Multi-threading: `process_operations > 5`
     - Persistence: `persistence_mechanisms > 0`

**Rationale:**
- Cryptominers connect to mining pools (multiple outbound connections)
- Mining algorithms require intensive computation (memory/CPU)
- Multi-threaded for parallel hashing
- Persistence ensures mining continues across reboots

**False Positive Mitigation:**
- Requires BOTH network pattern AND resource usage
- Network threshold (10 ops, 5 connections) excludes casual network clients
- Conservative thresholds minimize false positives on build systems

---

### 5. `detect_process_injector_pattern()`

**Detection Logic:**
- **Primary indicator (immediate detection):**
  - `code_injection_attempts > 0` (ptrace, process_vm_writev detected)
- **Secondary indicators:**
  - Memory + process ops: `memory_operations > 10 && process_operations > 3`
  - Self-modification + process ops: `self_modification_attempts > 0 && process_operations > 0`

**Rationale:**
- Process injection uses ptrace to attach to target process
- Memory must be made RWX via mprotect
- Injected code written to target memory
- Alternative: self-modification for in-process code injection

**False Positive Mitigation:**
- code_injection_attempts is direct signal from Week 2 syscall monitoring
- ptrace/process_vm_* syscalls are rare in legitimate sandboxed code
- Debuggers excluded by sandbox context
- JIT compilers unlikely in malware samples

---

## Threshold Justification

### File Operations Thresholds
- **50 operations:** Minimum for ransomware detection
  - Avoids flagging normal file I/O
  - Catches moderate-scale encryption
- **100 operations:** High-confidence ransomware indicator
  - Indicates aggressive file manipulation
  - Common in real ransomware samples

### Network Operations Thresholds
- **10 network operations:** Minimum for miner detection
  - Excludes single HTTP requests
  - Indicates sustained network activity
- **5 outbound connections:** Mining pool pattern
  - Primary pool + backup pools
  - Excludes single-server clients

### Memory Operations Thresholds
- **10 operations:** Moderate memory usage
  - Common in legitimate programs
  - Combined with other indicators for context
- **20 operations:** High memory usage
  - Indicates resource-intensive operations
  - Strong signal for cryptominers

### Process Operations Thresholds
- **3 operations:** Moderate process spawning
  - Excludes single fork/exec patterns
  - Indicates multi-process activity
- **5 operations:** High process spawning
  - Multi-threaded mining
  - Fork bomb detection

## False Positive Considerations

### Low Risk
- **Cryptominer detection:** Requires both network AND resource usage
- **Rootkit detection:** Privilege escalation blocked by seccomp
- **Process injector:** ptrace rarely used outside debuggers

### Moderate Risk
- **Keylogger detection:** Requires 2+ indicators to reduce FPs
- File path analysis would improve accuracy (future enhancement)

### Higher Risk
- **Ransomware detection:** File-heavy operations common in legitimate programs
- Mitigation: High thresholds (50+ ops) and multi-indicator approach
- Future enhancement: Track unlink/write ratio for better accuracy

## Integration with Week 2 Syscall Monitoring

All detection methods use metrics populated by `update_metrics_from_syscall()`:

| Metric | Populated by Syscalls |
|--------|----------------------|
| `file_operations` | open, write, read, unlink, rename, chmod, mkdir |
| `process_operations` | fork, vfork, clone, execve |
| `network_operations` | socket, connect, send, recv, bind, listen |
| `memory_operations` | mmap, mprotect, munmap, brk |
| `code_injection_attempts` | ptrace, process_vm_readv, process_vm_writev, mprotect |
| `privilege_escalation_attempts` | setuid, capset, mount, unshare, chroot, init_module |
| `persistence_mechanisms` | (detected via heuristics in mock mode) |
| `outbound_connections` | connect syscalls |
| `hidden_file_creates` | (detected via file path analysis - future) |
| `executable_drops` | (detected via chmod +x - future) |

## Future Enhancements

### Phase 1: Argument Parsing
- **File paths:** Detect /dev/input/*, /tmp/*, .dotfiles
- **Memory permissions:** Detect RWX pages in mprotect
- **IP addresses:** Track unique remote IPs in connect
- **File modes:** Detect chmod +x for executable drops

### Phase 2: Advanced Heuristics
- **Unlink ratio:** Track delete vs write ratio for ransomware
- **Timing patterns:** Detect rapid operations (ransomware burst)
- **Network beaconing:** Analyze periodic connection patterns
- **Entropy analysis:** Detect encryption via file content changes

### Phase 3: Machine Learning
- **Feature extraction:** Convert metrics to ML feature vectors
- **Classifier integration:** Use trained models for family classification
- **Confidence scores:** Replace boolean detection with probabilities
- **Online learning:** Adapt to new malware variants

## Testing Strategy

### Unit Tests (Recommended)
```cpp
// Test ransomware detection
BehavioralMetrics ransomware_metrics;
ransomware_metrics.file_operations = 150;
ransomware_metrics.temp_file_creates = 10;
ransomware_metrics.outbound_connections = 2;
EXPECT_TRUE(analyzer->detect_ransomware_pattern(ransomware_metrics));

// Test cryptominer detection
BehavioralMetrics miner_metrics;
miner_metrics.network_operations = 20;
miner_metrics.outbound_connections = 8;
miner_metrics.memory_operations = 30;
EXPECT_TRUE(analyzer->detect_cryptominer_pattern(miner_metrics));
```

### Integration Tests
- Real malware samples (with appropriate containment)
- Benign program samples (verify no false positives)
- Boundary condition testing (thresholds ±1)

## Files Modified

1. **Services/Sentinel/Sandbox/BehavioralAnalyzer.h**
   - Added 5 method declarations (lines 270-274)
   - Location: After `generate_suspicious_behaviors()` declaration

2. **Services/Sentinel/Sandbox/BehavioralAnalyzer.cpp**
   - Added 5 method implementations (lines 643-879)
   - Location: After `generate_suspicious_behaviors()` implementation
   - Total added: ~237 lines with comprehensive comments

## Compilation Status

✅ **SUCCESS** - Code compiles without errors or warnings

```bash
ninja libsentinelservice.a
[1/2] Building CXX object Services/Sentinel/CMakeFiles/sentinelservice.dir/Sandbox/BehavioralAnalyzer.cpp.o
[2/2] Linking CXX static library lib/libsentinelservice.a
```

## Next Steps

These methods will be integrated in **Task 3: Suspicious Behavior Descriptions**, where they will be called from `generate_suspicious_behaviors()` to provide detailed malware family identification in threat reports.

**Example usage in Task 3:**
```cpp
if (detect_ransomware_pattern(metrics)) {
    TRY(behaviors.try_append("Ransomware pattern detected: rapid file encryption + C2 beaconing"_string));
}
```

## Summary

- ✅ 5 detection methods implemented
- ✅ Conservative thresholds to minimize false positives
- ✅ Comprehensive comments explaining heuristics
- ✅ Integration with Week 2 syscall metrics
- ✅ Compiled successfully
- ✅ Ready for Task 3 integration
