/*
 * Copyright (c) 2025, Ladybird contributors
 * SPDX-License-Identifier: BSD-2-Clause
 */

#pragma once

#include <AK/ByteBuffer.h>
#include <AK/Error.h>
#include <AK/NonnullOwnPtr.h>
#include <AK/String.h>
#include <AK/Vector.h>

namespace Sentinel {

// Machine Learning-based malware detection using TensorFlow Lite
// Milestone 0.4 Phase 1: ML Infrastructure
class MalwareMLDetector {
public:
    // Feature vector extracted from file for ML model
    struct Features {
        u64 file_size { 0 };
        float entropy { 0.0f };          // Shannon entropy (0.0-8.0)
        u32 pe_header_anomalies { 0 };   // PE structure analysis (Windows executables)
        u32 suspicious_strings { 0 };    // High-entropy strings, URLs, IPs
        float code_section_ratio { 0.0f }; // Code vs. data ratio
        u32 import_table_size { 0 };     // Import table entries count

        // Convert to float vector for model input
        Vector<float> to_vector() const;
    };

    // Prediction result from ML model
    struct Prediction {
        float malware_probability { 0.0f }; // 0.0-1.0 (0 = benign, 1 = malware)
        float confidence { 0.0f };          // Model confidence (0.0-1.0)
        String explanation;                 // Human-readable feature importance
        Features features_used;             // Features that contributed to decision
    };

    // Statistics for monitoring ML performance
    struct Statistics {
        u64 total_predictions { 0 };
        u64 malware_detected { 0 };
        u64 benign_classified { 0 };
        float average_inference_time_ms { 0.0f };
        float average_confidence { 0.0f };
    };

    // Create ML detector with trained model
    // model_path: Path to .tflite model file (e.g., /usr/share/ladybird/models/malware.tflite)
    static ErrorOr<NonnullOwnPtr<MalwareMLDetector>> create(ByteString const& model_path);

    // Extract features from file data
    ErrorOr<Features> extract_features(ByteBuffer const& file_data);

    // Run prediction on extracted features
    ErrorOr<Prediction> predict(Features const& features);

    // Convenience: extract features and predict in one call
    ErrorOr<Prediction> analyze_file(ByteBuffer const& file_data);

    // Get detector statistics
    Statistics get_statistics() const { return m_stats; }
    void reset_statistics();

    // Model information
    String model_version() const { return m_model_version; }
    bool is_loaded() const { return m_model_loaded; }

private:
    MalwareMLDetector(ByteString const& model_path);

    ErrorOr<void> load_model();
    ErrorOr<void> initialize_interpreter();

    // Feature extraction helpers
    static float calculate_shannon_entropy(ByteBuffer const& data);
    static u32 count_suspicious_strings(ByteBuffer const& data);
    static bool is_pe_file(ByteBuffer const& data);
    static u32 analyze_pe_structure(ByteBuffer const& data);
    static float calculate_code_ratio(ByteBuffer const& data);
    static u32 extract_import_table_size(ByteBuffer const& data);

    // Generate human-readable explanation from features
    static String generate_explanation(Features const& features, float probability);

    ByteString m_model_path;
    String m_model_version { "0.1.0"_string };
    bool m_model_loaded { false };

    // TensorFlow Lite model and interpreter (opaque pointers)
    // We use void* to avoid exposing TFLite headers in public API
    [[maybe_unused]] void* m_model { nullptr };       // tflite::FlatBufferModel*
    [[maybe_unused]] void* m_interpreter { nullptr }; // tflite::Interpreter*

    // Model I/O tensors
    Vector<float> m_input_tensor;
    Vector<float> m_output_tensor;

    // Statistics tracking
    Statistics m_stats;
};

}
