/**
 * Malware Testing Helper Utilities
 *
 * Provides utility functions for malware detection tests including:
 * - File generation (EICAR, high-entropy samples)
 * - SHA256 computation
 * - Sentinel service interaction simulation
 * - PolicyGraph database helpers
 * - Test data validation
 */

import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

/**
 * EICAR test string - industry standard for antivirus testing
 * Safe to use, recognized by all major AV vendors as test file
 */
export const EICAR_STRING = 'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*';

/**
 * Compute SHA256 hash of content
 */
export function computeSHA256(content: string | Buffer): string {
  const hash = crypto.createHash('sha256');
  hash.update(content);
  return hash.digest('hex');
}

/**
 * Compute Shannon entropy of data (0.0 to 8.0)
 * Higher entropy suggests compression, encryption, or obfuscation
 */
export function computeEntropy(data: Buffer): number {
  if (data.length === 0) return 0;

  // Count byte frequencies
  const frequency = new Array(256).fill(0);
  for (const byte of data) {
    frequency[byte]++;
  }

  // Calculate entropy
  let entropy = 0;
  const dataSize = data.length;

  for (const count of frequency) {
    if (count === 0) continue;

    const probability = count / dataSize;
    entropy -= probability * Math.log2(probability);
  }

  return entropy;
}

/**
 * Generate high-entropy data (simulates packed/encrypted malware)
 */
export function generateHighEntropyData(size: number): Buffer {
  return crypto.randomBytes(size);
}

/**
 * Generate low-entropy data (clean text file)
 */
export function generateLowEntropyData(size: number): Buffer {
  const text = 'This is a legitimate text file. '.repeat(Math.ceil(size / 33));
  return Buffer.from(text.substring(0, size));
}

/**
 * Create EICAR test file
 */
export function createEICARFile(filename: string): void {
  fs.writeFileSync(filename, EICAR_STRING);
}

/**
 * Create clean test file
 */
export function createCleanFile(filename: string, size: number = 1024): void {
  const content = generateLowEntropyData(size);
  fs.writeFileSync(filename, content);
}

/**
 * Create PE file header (Windows executable marker)
 */
export function createPEHeader(): Buffer {
  const header = Buffer.alloc(64);

  // DOS header "MZ"
  header[0] = 0x4D; // 'M'
  header[1] = 0x5A; // 'Z'

  // PE offset at 0x3C (points to PE signature)
  header[0x3C] = 0x80;

  return header;
}

/**
 * Create ML suspicious file (high entropy, PE structure, suspicious strings)
 */
export function createMLSuspiciousFile(filename: string): void {
  const chunks: Buffer[] = [];

  // 1. PE header
  chunks.push(createPEHeader());

  // 2. High-entropy section (simulates encryption)
  chunks.push(generateHighEntropyData(512));

  // 3. Suspicious API strings
  const apis = [
    'VirtualAlloc',
    'CreateRemoteThread',
    'WriteProcessMemory',
    'LoadLibraryA',
    'GetProcAddress',
  ];
  chunks.push(Buffer.from(apis.join('\x00') + '\x00'));

  // 4. Suspicious URLs
  const urls = [
    'http://192.168.1.100/payload.exe',
    'https://attacker.com/c2server',
    'http://evil-domain.com/malware.exe',
  ];
  chunks.push(Buffer.from(urls.join('\x00') + '\x00'));

  // 5. More high-entropy data
  chunks.push(generateHighEntropyData(1024));

  // 6. PowerShell obfuscated command
  chunks.push(Buffer.from('powershell -enc JABzAD0ATgBlAHcALQBPAGIAagBlAGMAdAA='));

  // 7. Final padding
  chunks.push(generateHighEntropyData(512));

  const content = Buffer.concat(chunks);
  fs.writeFileSync(filename, content);
}

/**
 * Expected ML features for test files
 */
export interface MLFeatures {
  file_size: number;
  entropy: number;
  pe_header_anomalies: number;
  suspicious_strings: number;
  code_section_ratio: number;
  import_table_size: number;
}

/**
 * Compute expected ML features for a file
 */
export function computeMLFeatures(filename: string): MLFeatures {
  const content = fs.readFileSync(filename);

  return {
    file_size: content.length,
    entropy: computeEntropy(content),
    pe_header_anomalies: isPEFile(content) ? analyzePEAnomalies(content) : 0,
    suspicious_strings: countSuspiciousStrings(content),
    code_section_ratio: calculateCodeRatio(content),
    import_table_size: extractImportTableSize(content),
  };
}

/**
 * Check if file has PE header
 */
export function isPEFile(data: Buffer): boolean {
  return data.length >= 2 && data[0] === 0x4D && data[1] === 0x5A;
}

/**
 * Analyze PE structure for anomalies
 */
export function analyzePEAnomalies(data: Buffer): number {
  if (!isPEFile(data)) return 0;

  let anomalies = 0;

  // Check for valid PE offset
  if (data.length < 64) {
    anomalies += 50; // Truncated PE
    return anomalies;
  }

  const peOffset =
    data[0x3C] |
    (data[0x3D] << 8) |
    (data[0x3E] << 16) |
    (data[0x3F] << 24);

  if (peOffset > data.length - 4) {
    anomalies += 50; // Invalid PE offset
  }

  return anomalies;
}

/**
 * Count suspicious strings (URLs, IPs, API calls)
 */
export function countSuspiciousStrings(data: Buffer): number {
  const text = data.toString('utf8', 0, Math.min(data.length, 10000));

  let count = 0;

  // URLs
  const urlMatches = text.match(/https?:\/\/[a-z0-9\-\.]+/gi);
  if (urlMatches) count += urlMatches.length * 10;

  // IP addresses
  const ipMatches = text.match(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/g);
  if (ipMatches) count += ipMatches.length * 5;

  // Suspicious Windows APIs
  const apis = [
    'VirtualAlloc',
    'CreateRemoteThread',
    'WriteProcessMemory',
    'LoadLibrary',
    'GetProcAddress',
  ];
  for (const api of apis) {
    if (text.includes(api)) count += 15;
  }

  return count;
}

/**
 * Calculate code to data ratio (simplified heuristic)
 */
export function calculateCodeRatio(data: Buffer): number {
  if (data.length < 1024) return 0.5;

  let codeBytes = 0;
  let dataBytes = 0;

  // Sample first 10KB
  const sampleSize = Math.min(data.length, 10240);

  for (let i = 0; i < sampleSize; i++) {
    const byte = data[i];

    // Heuristic: 0x00, 0xFF likely data/padding
    if (byte === 0x00 || byte === 0xFF) {
      dataBytes++;
    }
    // x86/x64 instruction opcodes
    else if (
      (byte >= 0x40 && byte <= 0x5F) || // REX, PUSH/POP
      (byte >= 0x80 && byte <= 0x8F) || // Conditional jumps
      byte === 0xE8 ||
      byte === 0xE9 // CALL, JMP
    ) {
      codeBytes++;
    } else {
      dataBytes++;
    }
  }

  if (codeBytes + dataBytes === 0) return 0.5;
  return codeBytes / (codeBytes + dataBytes);
}

/**
 * Extract import table size (simplified)
 */
export function extractImportTableSize(data: Buffer): number {
  const text = data.toString('utf8', 0, Math.min(data.length, 10000));

  let importCount = 0;

  // Common Windows DLLs
  const dlls = ['kernel32.dll', 'user32.dll', 'advapi32.dll', 'ntdll.dll'];

  for (const dll of dlls) {
    if (text.includes(dll)) importCount += 10;
  }

  return importCount;
}

/**
 * Sentinel mock response for testing
 */
export interface SentinelResponse {
  status: 'success' | 'error';
  result?: string; // "clean" or JSON alert
  error?: string;
}

/**
 * Generate mock Sentinel response for EICAR
 */
export function mockSentinelEICARResponse(): SentinelResponse {
  return {
    status: 'success',
    result: JSON.stringify({
      threat_detected: true,
      rule_name: 'EICAR_Test_File',
      severity: 'test',
      description: 'EICAR test file - industry standard for AV testing',
      recommendation: 'This is a test file, safe to delete',
    }),
  };
}

/**
 * Generate mock Sentinel response for clean file
 */
export function mockSentinelCleanResponse(): SentinelResponse {
  return {
    status: 'success',
    result: 'clean',
  };
}

/**
 * Generate mock Sentinel response for ML detection
 */
export function mockSentinelMLResponse(probability: number): SentinelResponse {
  return {
    status: 'success',
    result: JSON.stringify({
      threat_detected: true,
      detection_type: 'ml_based',
      malware_probability: probability,
      confidence: 0.92,
      explanation:
        'High entropy (7.80) suggests encryption/packing; ' +
        '35 PE structure anomalies detected; ' +
        '120 suspicious strings found (URLs, APIs)',
      severity: 'high',
      recommendation: 'Quarantine or delete this file',
    }),
  };
}

/**
 * PolicyGraph mock entry for scan result
 */
export interface PolicyGraphScanResult {
  sha256: string;
  verdict: 'clean' | 'malware' | 'quarantined' | 'blocked_by_user' | 'allowed_by_user';
  scan_time_ms: number;
  yara_rules_matched: number;
  ml_probability?: number;
  timestamp: number;
}

/**
 * Create mock PolicyGraph scan result
 */
export function createMockScanResult(
  content: string | Buffer,
  verdict: PolicyGraphScanResult['verdict']
): PolicyGraphScanResult {
  const sha256 = computeSHA256(content);

  return {
    sha256,
    verdict,
    scan_time_ms: Math.floor(Math.random() * 500) + 100,
    yara_rules_matched: verdict === 'malware' ? 1 : 0,
    ml_probability: verdict === 'malware' ? 0.87 : 0.03,
    timestamp: Date.now(),
  };
}

/**
 * Generate large file for performance testing
 */
export function generateLargeFile(filename: string, sizeMB: number): void {
  const chunkSize = 1024 * 1024; // 1MB chunks
  const fd = fs.openSync(filename, 'w');

  for (let i = 0; i < sizeMB; i++) {
    const chunk = generateLowEntropyData(chunkSize);
    fs.writeSync(fd, chunk);
  }

  fs.closeSync(fd);
}

/**
 * Telemetry data for worker pool
 */
export interface WorkerPoolTelemetry {
  total_scans_completed: number;
  total_scans_failed: number;
  current_queue_depth: number;
  active_workers: number;
  avg_scan_time_ms: number;
}

/**
 * Create mock worker pool telemetry
 */
export function createMockTelemetry(scansCompleted: number): WorkerPoolTelemetry {
  return {
    total_scans_completed: scansCompleted,
    total_scans_failed: 0,
    current_queue_depth: 0,
    active_workers: 2,
    avg_scan_time_ms: 350,
  };
}

/**
 * Validate test file against expected properties
 */
export function validateTestFile(filename: string, expected: Partial<MLFeatures>): boolean {
  const actual = computeMLFeatures(filename);

  if (expected.entropy !== undefined) {
    if (Math.abs(actual.entropy - expected.entropy) > 1.0) {
      console.error(`Entropy mismatch: expected ${expected.entropy}, got ${actual.entropy}`);
      return false;
    }
  }

  if (expected.file_size !== undefined) {
    if (actual.file_size !== expected.file_size) {
      console.error(`File size mismatch: expected ${expected.file_size}, got ${actual.file_size}`);
      return false;
    }
  }

  return true;
}

/**
 * Clean up test files
 */
export function cleanupTestFiles(directory: string): void {
  if (!fs.existsSync(directory)) return;

  const files = fs.readdirSync(directory);
  for (const file of files) {
    const filepath = path.join(directory, file);
    if (fs.statSync(filepath).isFile()) {
      fs.unlinkSync(filepath);
    }
  }
}

/**
 * Format bytes to human-readable size
 */
export function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Wait for a condition with timeout
 */
export async function waitForCondition(
  condition: () => boolean,
  timeoutMs: number = 5000,
  checkIntervalMs: number = 100
): Promise<boolean> {
  const startTime = Date.now();

  while (Date.now() - startTime < timeoutMs) {
    if (condition()) {
      return true;
    }
    await new Promise(resolve => setTimeout(resolve, checkIntervalMs));
  }

  return false;
}
