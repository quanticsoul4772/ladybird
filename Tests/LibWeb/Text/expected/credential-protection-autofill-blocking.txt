=== Credential Protection: Autofill Blocking Test ===
undefined
Test 1: Form and field configuration
  form action: https://attacker.example.com/collect
  form is cross-origin: true
  username field exists: true
  username autocomplete: username
  password field exists: true
  password autocomplete: current-password
undefined
Test 2: Autofill attributes present
  username has autocomplete attr: true
  password has autocomplete attr: true
  username autocomplete value: username
  password autocomplete value: current-password
undefined
Test 3: Cross-origin submission indicators
  current origin: file://
  action origin: https://attacker.example.com
  origins match: false
  is suspicious: true
undefined
Test 4: Autofill blocking workflow
undefined
  Step 1: USER FOCUSES PASSWORD FIELD
    - Browser's autofill manager activated
    - FormMonitor.can_autofill() is called
    - FormMonitor checks if form is cross-origin
    - FormMonitor checks m_trusted_relationships
undefined
  Step 2: FORMMONITOR DECISION
    - If form is cross-origin AND not trusted:
      * can_autofill() returns false
      * Autofill is blocked
      * on_autofill_blocked callback triggered
    - If form is trusted:
      * can_autofill() returns true
      * Autofill proceeds normally
undefined
  Step 3: USER NOTIFICATION
    - UI receives on_autofill_blocked callback
    - Banner shown: 'Autofill blocked for security reasons'
    - Details: form_origin, action_origin, reason
    - User informed they must type credentials manually
undefined
  Step 4: ONE-TIME OVERRIDE
    - User can click 'Allow Once' in banner
    - Banner calls grant_autofill_override()
    - Override stored in m_autofill_overrides HashMap
    - User can trigger autofill manually
    - Override consumed after single use
undefined
Test 5: FormMonitor autofill protection logic
  can_autofill(form_element, field_element):
    1. Extract form action origin
    2. Extract form document origin
    3. If same origin: return true (allow)
    4. If cross-origin:
       a. Check m_trusted_relationships for trust
       b. If trusted: return true (allow)
       c. If not trusted:
          - Check m_autofill_overrides for one-time override
          - If override exists:
            * Consume override (remove from map)
            * return true (allow once)
          - If no override:
            * Trigger on_autofill_blocked callback
            * return false (block)
undefined
Test 6: FormMonitor data structures for autofill
  m_autofill_overrides: HashMap<ByteString, bool>
    - Key: form_origin + action_origin hash
    - Value: true (override active)
    - Single-use: removed after consumption
    - Expires when form navigation occurs
undefined
  m_trusted_relationships: HashMap<ByteString, Vector<ByteString>>
    - Persistent trust (until revoked)
    - Allows both submission and autofill
    - Checked before autofill override
undefined
Test 7: Security rationale for autofill blocking
  - Prevents credential theft via invisible form fields
  - Stops autofill from populating attacker-controlled forms
  - Forces user awareness for cross-origin credential sharing
  - Gives user explicit control via 'Allow Once' mechanism
  - Protects against phishing with embedded forms
undefined
Test 8: User experience considerations
  Legitimate use case: OpenID/OAuth redirects
    - User redirected to identity provider
    - Identity provider is cross-origin
    - Autofill initially blocked
    - User trusts provider
    - Future autofills allowed
undefined
  Malicious use case: Phishing attack
    - Attacker embeds cross-origin form
    - User focuses password field
    - Autofill blocked
    - Banner alerts user to suspicious behavior
    - User recognizes threat and navigates away
undefined
=== Expected IPC Flow ===
Autofill blocked:
  1. Browser autofill manager calls can_autofill()
  2. FormMonitor returns false
  3. FormMonitor calls client.async_did_block_autofill()
  4. WebContent -> UI IPC message sent
  5. UI Tab.cpp receives on_autofill_blocked callback
  6. UI shows autofill blocked banner
undefined
User grants override:
  1. User clicks 'Allow Once' button
  2. UI -> WebContent: async_grant_autofill_override()
  3. WebContent calls FormMonitor.grant_autofill_override()
  4. Override stored in m_autofill_overrides
  5. User can trigger autofill manually
  6. Next autofill consumes override
undefined
=== Test Complete ===
Autofill blocking protects against credential theft via autofill.
