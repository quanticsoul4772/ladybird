# Example: Integrating External Dependencies

# ============================================================
# Pattern 1: vcpkg Package (Preferred)
# ============================================================
# Best for widely-used libraries available in vcpkg

# Step 1: Add to vcpkg.json (root of repository)
# {
#   "dependencies": [
#     "your-package",
#     {
#       "name": "your-package",
#       "version>=": "1.0.0"
#     }
#   ]
# }

# Step 2: Use find_package in CMakeLists.txt
find_package(YourPackage REQUIRED)

# Step 3: Link the package
target_link_libraries(YourTarget
    PRIVATE YourPackage::YourPackage
)

# Example: Using CURL (already in vcpkg.json)
find_package(CURL REQUIRED)
target_link_libraries(YourTarget PRIVATE CURL::libcurl)

# Example: Using Qt6 (conditional)
if (ENABLE_QT AND ENABLE_GUI_TARGETS)
    find_package(Qt6 REQUIRED COMPONENTS Core Widgets Network)
    target_link_libraries(YourTarget
        PRIVATE
            Qt6::Core
            Qt6::Widgets
            Qt6::Network
    )
endif()

# Example: Using ICU (International Components for Unicode)
find_package(ICU REQUIRED COMPONENTS uc i18n data)
target_link_libraries(YourTarget
    PRIVATE
        ICU::uc     # Unicode common
        ICU::i18n   # Internationalization
        ICU::data   # ICU data
)

# Example: Using OpenSSL (already required globally)
find_package(OpenSSL REQUIRED)
target_link_libraries(YourTarget
    PRIVATE
        OpenSSL::Crypto
        OpenSSL::SSL
)

# ============================================================
# Pattern 2: pkg-config Package (System Libraries)
# ============================================================
# Best for system libraries not in vcpkg

find_package(PkgConfig REQUIRED)

# Find single package
pkg_check_modules(yourlib REQUIRED IMPORTED_TARGET yourlib)
target_link_libraries(YourTarget PRIVATE PkgConfig::yourlib)

# Example: Finding ANGLE (OpenGL ES implementation)
pkg_check_modules(angle REQUIRED IMPORTED_TARGET angle)
target_link_libraries(YourTarget PRIVATE PkgConfig::angle)

# Example: Finding multiple alternatives
find_package(unofficial-angle CONFIG)
if(unofficial-angle_FOUND)
    set(ANGLE_TARGETS unofficial::angle::libEGL unofficial::angle::libGLESv2)
else()
    find_package(PkgConfig)
    pkg_check_modules(angle REQUIRED IMPORTED_TARGET angle)
    set(ANGLE_TARGETS PkgConfig::angle)
endif()
target_link_libraries(YourTarget PRIVATE ${ANGLE_TARGETS})

# ============================================================
# Pattern 3: Custom Library (Manual Find)
# ============================================================
# Best for libraries without package config

# Find library file
find_library(YOURLIB_LIBRARY
    NAMES yourlib libyourlib yourlibrary
    PATHS
        /usr/lib
        /usr/lib/x86_64-linux-gnu
        /usr/lib/aarch64-linux-gnu
        /usr/local/lib
        /opt/homebrew/lib  # macOS ARM
    DOC "YourLib library"
)

# Find header directory
find_path(YOURLIB_INCLUDE_DIR
    yourlib.h
    PATHS
        /usr/include
        /usr/local/include
        /opt/homebrew/include  # macOS ARM
    PATH_SUFFIXES yourlib
    DOC "YourLib include directory"
)

# Check if found
if(NOT YOURLIB_LIBRARY)
    message(WARNING "YourLib library not found. Feature will be disabled.")
    message(WARNING "Install YourLib with: sudo apt-get install libyourlib-dev")
    target_compile_definitions(YourTarget PRIVATE NO_YOURLIB_SUPPORT=1)
else()
    message(STATUS "Found YourLib library: ${YOURLIB_LIBRARY}")
    message(STATUS "Found YourLib include: ${YOURLIB_INCLUDE_DIR}")

    target_include_directories(YourTarget PRIVATE ${YOURLIB_INCLUDE_DIR})
    target_link_libraries(YourTarget PRIVATE ${YOURLIB_LIBRARY})
    target_compile_definitions(YourTarget PRIVATE HAS_YOURLIB_SUPPORT=1)
endif()

# Real example: YARA (from Services/Sentinel/CMakeLists.txt)
find_library(YARA_LIBRARY
    NAMES yara libyara
    PATHS /usr/lib /usr/lib/x86_64-linux-gnu /usr/local/lib
)
find_path(YARA_INCLUDE_DIR
    yara.h
    PATHS /usr/include /usr/local/include
)

if(NOT YARA_LIBRARY)
    message(WARNING "YARA library not found. Sentinel will not build.")
    message(WARNING "Install YARA with: sudo apt-get install libyara-dev yara")
else()
    message(STATUS "Found YARA library: ${YARA_LIBRARY}")
    message(STATUS "Found YARA include: ${YARA_INCLUDE_DIR}")
    target_include_directories(sentinelservice PRIVATE ${YARA_INCLUDE_DIR})
    target_link_libraries(sentinelservice PRIVATE ${YARA_LIBRARY})
endif()

# ============================================================
# Pattern 4: Header-Only Library
# ============================================================
# Best for header-only libraries (e.g., nlohmann/json, fmt)

# Via vcpkg (preferred):
find_package(nlohmann_json REQUIRED)
target_link_libraries(YourTarget PRIVATE nlohmann_json::nlohmann_json)

# Manual (if not in vcpkg):
find_path(JSON_INCLUDE_DIR
    nlohmann/json.hpp
    PATHS /usr/include /usr/local/include
)
if(JSON_INCLUDE_DIR)
    target_include_directories(YourTarget PRIVATE ${JSON_INCLUDE_DIR})
else()
    message(FATAL_ERROR "nlohmann/json not found")
endif()

# ============================================================
# Pattern 5: Platform-Specific Dependencies
# ============================================================

if (APPLE)
    # macOS frameworks
    find_library(COREFOUNDATION_LIBRARY CoreFoundation REQUIRED)
    find_library(FOUNDATION_LIBRARY Foundation REQUIRED)
    target_link_libraries(YourTarget
        PRIVATE
            ${COREFOUNDATION_LIBRARY}
            ${FOUNDATION_LIBRARY}
    )
elseif (WIN32)
    # Windows system libraries
    target_link_libraries(YourTarget
        PRIVATE
            ws2_32      # Winsock
            bcrypt      # Cryptography
            userenv     # User environment
    )
elseif (UNIX)
    # Linux system libraries
    target_link_libraries(YourTarget PRIVATE pthread dl)

    # Solaris-specific
    if (${CMAKE_SYSTEM_NAME} MATCHES "SunOS")
        target_link_libraries(YourTarget PUBLIC nsl socket)
    endif()

    # Haiku-specific
    if (HAIKU)
        target_link_libraries(YourTarget PRIVATE network)
    endif()
endif()

# ============================================================
# Pattern 6: Optional Dependencies
# ============================================================
# Best for features that can be disabled

# Option to enable/disable
option(ENABLE_FEATURE_X "Enable Feature X support" ON)

if (ENABLE_FEATURE_X)
    find_package(FeatureXLibrary)

    if (FeatureXLibrary_FOUND)
        target_link_libraries(YourTarget PRIVATE FeatureXLibrary::FeatureXLibrary)
        target_compile_definitions(YourTarget PRIVATE HAS_FEATURE_X=1)
    else()
        message(WARNING "Feature X library not found. Feature X disabled.")
        target_compile_definitions(YourTarget PRIVATE HAS_FEATURE_X=0)
    endif()
else()
    message(STATUS "Feature X disabled via ENABLE_FEATURE_X=OFF")
    target_compile_definitions(YourTarget PRIVATE HAS_FEATURE_X=0)
endif()

# ============================================================
# Pattern 7: Version Requirements
# ============================================================

# Exact version
find_package(YourPackage 2.0 EXACT REQUIRED)

# Minimum version
find_package(YourPackage 1.5 REQUIRED)

# Version range (CMake 3.19+)
find_package(YourPackage 1.5...2.0 REQUIRED)

# Check version manually
find_package(YourPackage REQUIRED)
if (YourPackage_VERSION VERSION_LESS "1.5.0")
    message(FATAL_ERROR "YourPackage version ${YourPackage_VERSION} too old, need 1.5.0+")
endif()

# ============================================================
# Pattern 8: Dependency with Custom Build
# ============================================================
# Best for dependencies that need special configuration

include(ExternalProject)

ExternalProject_Add(
    external_yourlib
    PREFIX ${CMAKE_BINARY_DIR}/external/yourlib
    URL https://example.com/yourlib-1.0.tar.gz
    URL_HASH SHA256=abcdef123456...
    CMAKE_ARGS
        -DCMAKE_INSTALL_PREFIX=${CMAKE_BINARY_DIR}/external/yourlib
        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
    BUILD_BYPRODUCTS ${CMAKE_BINARY_DIR}/external/yourlib/lib/libyourlib.a
)

add_library(YourLib STATIC IMPORTED)
set_target_properties(YourLib PROPERTIES
    IMPORTED_LOCATION ${CMAKE_BINARY_DIR}/external/yourlib/lib/libyourlib.a
)
add_dependencies(YourLib external_yourlib)

target_link_libraries(YourTarget PRIVATE YourLib)

# ============================================================
# Pattern 9: Embedded Dependencies (Discouraged)
# ============================================================
# Only use if absolutely necessary, prefer vcpkg

# Add third-party subdirectory
add_subdirectory(ThirdParty/yourlib)
target_link_libraries(YourTarget PRIVATE yourlib)

# Or add sources directly
target_sources(YourTarget
    PRIVATE
        ThirdParty/yourlib/yourlib.cpp
        ThirdParty/yourlib/yourlib.h
)
target_include_directories(YourTarget
    PRIVATE ThirdParty/yourlib
)

# ============================================================
# Pattern 10: Conditional Linking
# ============================================================

# Create interface library for conditional dependencies
add_library(YourTarget_dependencies INTERFACE)

if (ENABLE_FEATURE_A)
    target_link_libraries(YourTarget_dependencies INTERFACE FeatureALib)
endif()

if (ENABLE_FEATURE_B)
    target_link_libraries(YourTarget_dependencies INTERFACE FeatureBLib)
endif()

target_link_libraries(YourTarget PRIVATE YourTarget_dependencies)

# ============================================================
# Best Practices
# ============================================================

# 1. Always check if dependency is found
#    - Use REQUIRED if mandatory
#    - Handle gracefully if optional

# 2. Use PUBLIC/PRIVATE/INTERFACE correctly
#    - PUBLIC: Exposed in your public headers
#    - PRIVATE: Used only in .cpp files
#    - INTERFACE: Header-only, no .cpp

# 3. Prefer vcpkg packages over manual find
#    - More portable
#    - Better version management
#    - Easier for contributors

# 4. Document installation requirements
#    - Add to Documentation/BuildInstructions*.md
#    - Include install commands in error messages

# 5. Use find modules from Meta/CMake/
#    - Check Meta/CMake/Find*.cmake for existing modules
#    - Create new module if needed

# 6. Test on multiple platforms
#    - Linux (Ubuntu, Fedora)
#    - macOS (Intel, ARM)
#    - Windows (experimental)

# 7. Graceful degradation
#    - Disable features if dependencies missing
#    - Don't fail the entire build for optional features

# ============================================================
# Troubleshooting
# ============================================================

# Dependency not found:
# 1. Check if in vcpkg: vcpkg search <package>
# 2. Check system packages: apt search <package>
# 3. Check Meta/CMake/Find*.cmake modules
# 4. Add to vcpkg.json if available in vcpkg

# Wrong version found:
# 1. Specify version in find_package()
# 2. Set CMAKE_PREFIX_PATH to override
# 3. Use vcpkg overlay triplets

# Link errors:
# 1. Check library order (dependencies last)
# 2. Verify target names (Foo::Foo vs Foo)
# 3. Check PUBLIC/PRIVATE visibility
# 4. Use -DCMAKE_VERBOSE_MAKEFILE=ON to debug

# vcpkg issues:
# 1. Clean vcpkg: rm -rf Build/vcpkg Build/caches
# 2. Rebuild vcpkg: ./Meta/ladybird.py vcpkg
# 3. Check vcpkg logs in Build/vcpkg/buildtrees/
